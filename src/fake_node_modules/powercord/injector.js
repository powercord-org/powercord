const { randomBytes } = require('crypto');
const { instance } = require('powercord/webpack');

const getProp = (obj, path) =>
  path.length
    ? getProp(obj[path.shift()], path)
    : obj;

const injector = {
  injections: [],

  inject: (injectionId, mod, funcName, patch, pre = false) => {
    if (!mod) {
      return injector._error(`Tried to patch undefined (Injection ID "${injectionId}")`);
    }

    if (injector.injections.find(i => i.id === injectionId)) {
      return injector._error(`Injection ID "${injectionId}" is already used!`);
    }

    if (!mod.__powercordInjectionId || !mod.__powercordInjectionId[funcName]) {
      // 1st injection
      const id = randomBytes(16).toString('hex');
      mod.__powercordInjectionId = Object.assign((mod.__powercordInjectionId || {}), { [funcName]: id });
      mod[funcName] = (_oldMethod => function (...args) {
        const finalArgs = injector._runPreInjections(id, args, this);
        if (finalArgs !== false && Array.isArray(finalArgs)) {
          const returned = _oldMethod ? _oldMethod.call(this, ...finalArgs) : void 0;
          return injector._runInjections(id, finalArgs, returned, this);
        }
      })(mod[funcName]);

      injector.injections[id] = [];
    }

    injector.injections.push({
      module: mod.__powercordInjectionId[funcName],
      id: injectionId,
      method: patch,
      pre
    });
  },

  injectRecursive: (injectionId, root, paths, func) => new Promise(resolve => {
    const node = {
      prop: paths[0].path || 'render',
      path: typeof paths[0] === 'string'
        ? paths.shift().split('.')
        : paths.shift().path.split('.')
    };

    injector.inject(injectionId, getProp(root, node.path), node.prop, function (args, res) {
      if (paths.length === 0) {
        func.call(this, args, res);
      } else {
        injector.uninject(injectionId);
        resolve(injector.injectRecursive(injectionId, res, paths, func));
      }

      return res;
    });
  }),

  injectInFluxContainer: (injectionId, componentName, funcName, patch) => new Promise(resolve => {
    const injections = [];
    const cache = Object.values(instance.cache)
      .filter(m => (
        m.exports &&
        m.exports.$$typeof &&
        m.exports.$$typeof.toString() === 'Symbol(react.forward_ref)'
      ));

    for (const i in cache) {
      const e = cache[i];
      const tempInjectionID = `tmp-${injectionId}-${i}`;
      injections.push(tempInjectionID);
      injector.inject(tempInjectionID, e.exports, 'render', (_, res) => { // Context: ForwardProp
        injector.uninject(tempInjectionID);

        if (res.type.prototype) {
          injector.inject(tempInjectionID, res.type.prototype, 'render', function (_, res) { // Context: FluxContainer
            injector.uninject(tempInjectionID);

            if (
              res.type &&
              res.type.displayName &&
              res.type.displayName.toLowerCase() === componentName.toLowerCase()
            ) {
              // Injection target found
              for (const injectionID of injections) {
                injector.uninject(injectionID);
              }
              injector.inject(injectionId, res.type.prototype, funcName, patch);
              resolve();
            }

            this.forceUpdate();

            return res;
          });
        }

        return res;
      });
    }
  }),

  uninject: (injectionId) => {
    injector.injections = injector.injections.filter(i => i.id !== injectionId);
  },

  _runPreInjections: (modId, originArgs, _this) => {
    const injections = injector.injections.filter(i => i.module === modId && i.pre);
    if (injections.length === 0) {
      return originArgs;
    }
    return injector._runPreInjectionsRecursive(injections, originArgs, _this);
  },

  _runPreInjectionsRecursive: (injections, originalArgs, _this) => {
    const injection = injections.pop();
    let args = injection.method.call(_this, originalArgs);
    if (args === false) {
      return false;
    }

    if (!Array.isArray(args)) {
      injector._error(`Pre-injection ${injection.id} returned something invalid. Injection will be ignored.`);
      args = originalArgs;
    }

    if (injections.length > 0) {
      return injector._runPreInjectionsRecursive(injections, args, _this);
    }
    return args;
  },

  _runInjections: (modId, originArgs, originReturn, _this) => {
    let finalReturn = originReturn;
    const injections = injector.injections.filter(i => i.module === modId && !i.pre);
    injections.forEach(i => {
      try {
        finalReturn = i.method.call(_this, originArgs, finalReturn);
      } catch (e) {
        injector._error(`Failed to run injection "${i.id}"`, e);
      }
    });
    return finalReturn;
  },

  _error: (...args) => {
    console.error('%c[Powercord:Injector]', 'color: #257dd4', ...args);
  }
};

module.exports = injector;
