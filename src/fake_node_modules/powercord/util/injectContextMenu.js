// Credit: og impl by Samm-Cheese#9500
// https://discord.com/channels/538759280057122817/755005784999329883/937176673424666744

const wrapInHooks = require('./wrapInHooks.js');

// Lazily required
let getModule, inject, uninject;
let cachedContextMenuOpener;

/**
 * Injects into a context menu, awaiting for its load if necessary.
 *
 * @param {string} injectionId Injection ID (like for injector.inject)
 * @param {string} displayName Display name of the context menu you want to patch
 * @param {function} fn Function to inject (like for injector.inject)
 * @param {boolean} pre Whether this is a pre-injection or not (like for injector.inject)
 */
async function injectContextMenu (injectionId, displayName, fn, pre = false) {
  if (!getModule) { // Lazy require moment
    /* eslint-disable prefer-destructuring */
    const injector = require('powercord/injector');
    getModule = require('powercord/webpack').getModule;
    inject = injector.inject;
    uninject = injector.uninject;
    /* eslint-enable prefer-destructuring */
  }

  const filter = (m) => m.default?.displayName === displayName;
  const patch = (m) => {
    const og = m.default;
    inject(injectionId, m, 'default', fn, pre);
    Object.assign(m.default, og);
  };

  const mdl = getModule(filter, false);
  if (mdl) {
    patch(mdl);
    return;
  }

  if (!cachedContextMenuOpener) {
    cachedContextMenuOpener = getModule([ 'openContextMenuLazy' ], false);
  }

  // Using the same injection id for the actual injection and
  // the await strategy allows for uninject to behave as expected
  // and will not conflict here. we could use a shared await strategy
  // but it's a bit more complex to setup and not really worth
  // the troubles imo
  let patched = false;
  inject(injectionId, cachedContextMenuOpener, 'openContextMenuLazy', (args) => {
    const [ , loader ] = args;
    args[1] = async () => {
      const wrapper = await loader(args[0]);
      return (props) => {
        const res = wrapper(props);
        if (!patched) {
          // Wrapped in AnalyticsContext
          const ctx = typeof res.type === 'object' ? res.props.children : res;
          if (!ctx.type.displayName) {
            if (typeof ctx.type !== 'function') {
              return res;
            }

            const children = wrapInHooks(ctx.type)(ctx.props);
            if (children.props.children.type.displayName === displayName) {
              patched = true;
              uninject(injectionId);

              const wrappedModule = getModule((m) => m.default === ctx.type || m.__powercordOriginal_default === ctx.type, false);
              let memoizedReplacement;
              inject(injectionId, wrappedModule, 'default', (_, res) => {
                if (!memoizedReplacement) {
                  const ogContextMenu = res.props.children.type;
                  memoizedReplacement = (...args) => {
                    if (pre) {
                      return ogContextMenu(...fn(args));
                    }

                    const res = ogContextMenu(...args);
                    return fn(args, res);
                  };
                  Object.assign(memoizedReplacement, ogContextMenu);
                  memoizedReplacement.toString = () => ogContextMenu.toString();
                }

                res.props.children.type = memoizedReplacement;
                return res;
              });

              // Make patch apply
              ctx.type = wrappedModule.default;
            }

            return res;
          }

          if (res.type.displayName === displayName) {
            patched = true;
            uninject(injectionId);
            const contextMenu = getModule(filter, false);
            patch(contextMenu);

            // Re-render, now with our added patch
            res.type = contextMenu.default;
          }
        }

        return res;
      };
    };

    return args;
  }, true);
}

module.exports = injectContextMenu;
