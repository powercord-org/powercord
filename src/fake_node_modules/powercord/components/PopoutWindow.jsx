/**
 * Powercord, a lightweight @discordapp client mod focused on simplicity and performance
 * Copyright (C) 2018-2020  aetheryx & Bowser65
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

const { React, Flux, getModule, getModuleByDisplayName } = require('powercord/webpack');
const AsyncComponent = require('./AsyncComponent');

const I18nLoaderWrapper = AsyncComponent.from(getModuleByDisplayName('FluxContainer(I18nLoaderWrapper)'));
const ErrorBoundary = AsyncComponent.from(getModuleByDisplayName('ErrorBoundary'));

class PopoutWindow extends React.PureComponent {
  componentDidMount () {
    // noinspection JSIgnoredPromiseFromCall
    this.htmlProps();
  }

  componentDidUpdate () {
    // noinspection JSIgnoredPromiseFromCall
    this.htmlProps();
  }

  async htmlProps () {
    /*
     * WhY nOt UsE rEaCt hElmEt??
     * Discord's impl for popout windows is a bit weird (kinda smart tho):
     * They basically render the component inside the **parent** window and then pass it to the child window.
     *
     * It means no need for the child window to populate its cache or anything, but that means global objects like
     * `document` refers to the **parent** window and not the child window. Which means ReactHelmet cannot work.
     */
    const guestWindow = this.props.windowManager.getWindow(this.props.windowId);
    guestWindow.document.head.parentElement.className = [ `theme-${this.props.theme}`, this.props.fontScaleClass ].filter(Boolean).join(' ');
    guestWindow.document.head.parentElement.style = `font-size: ${this.props.fontScale}%`;
    guestWindow.document.head.parentElement.lang = this.props.locale;
    guestWindow.document.querySelector('#app-mount').style.height = '100%';
  }

  render () {
    const { AppLayerProvider, AppLayerContainer } = this.props.layerModule;
    return (
      <I18nLoaderWrapper locale={this.props.locale}>
        <ErrorBoundary>
          <AppLayerProvider>
            {this.props.children}
            <AppLayerContainer/>
          </AppLayerProvider>
        </ErrorBoundary>
      </I18nLoaderWrapper>
    );
  }
}

module.exports = AsyncComponent.from((async () => {
  const windowManager = await getModule([ 'getWindow' ]);
  const layerModule = await getModule([ 'AppLayerProvider' ]);
  const settings1Store = await getModule([ 'theme', 'locale' ]);
  const settings2Store = await getModule([ 'fontScale', 'darkSidebar' ]);
  const Component = props => (
    <PopoutWindow
      {...props}
      windowManager={windowManager}
      layerModule={layerModule}
    />
  );

  return Flux.connectStores(
    [ settings1Store, settings2Store ],
    () => ({
      locale: settings1Store.locale,
      theme: settings1Store.theme,
      fontScale: settings2Store.fontScale,
      fontScaleClass: settings2Store.fontScaleClass
    })
  )(Component);
})());

